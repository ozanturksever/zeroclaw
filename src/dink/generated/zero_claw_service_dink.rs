// Code generated by dink codegen. DO NOT EDIT.

use super::types::*;
use async_trait::async_trait;
use dink_sdk::{Result as DinkResult, ServiceCaller, ServiceDefinition, ServiceHandler};

/// Server trait for ZeroClawService.
/// Implement this trait on the edge to handle incoming RPC calls.
#[async_trait]
pub trait ZeroClawServiceServer: Send + Sync {
    async fn send_message(&self, req: SendMessageRequest) -> DinkResult<SendMessageResponse>;
    async fn stream_message(
        &self,
        req: SendMessageRequest,
        emit: Box<dyn Fn(Vec<u8>) -> DinkResult<()> + Send + Sync>,
    ) -> DinkResult<()>;
    async fn get_status(&self, req: GetStatusRequest) -> DinkResult<GetStatusResponse>;
    async fn recall_memory(&self, req: RecallMemoryRequest) -> DinkResult<RecallMemoryResponse>;
    async fn update_config(&self, req: UpdateConfigRequest) -> DinkResult<UpdateConfigResponse>;
    async fn shutdown(&self, req: ShutdownRequest) -> DinkResult<ShutdownResponse>;
}

#[cfg(feature = "client")]
/// Typed client for ZeroClawService.
/// Wraps a `ServiceCaller` to make typed RPC calls to a remote edge.
pub struct ZeroClawServiceClient<C: ServiceCaller> {
    edge_id: String,
    caller: C,
}

#[cfg(feature = "client")]
impl<C: ServiceCaller> ZeroClawServiceClient<C> {
    pub fn new(edge_id: String, caller: C) -> Self {
        Self { edge_id, caller }
    }

    pub fn edge_id(&self) -> &str {
        &self.edge_id
    }

    pub async fn send_message(&self, req: &SendMessageRequest) -> DinkResult<SendMessageResponse> {
        let req_data = serde_json::to_vec(req).map_err(dink_sdk::DinkError::from)?;
        let resp_data = self
            .caller
            .call(&self.edge_id, "ZeroClawService", "SendMessage", &req_data)
            .await?;
        let resp: SendMessageResponse =
            serde_json::from_slice(&resp_data).map_err(dink_sdk::DinkError::from)?;
        Ok(resp)
    }

    pub async fn stream_message(
        &self,
        req: &SendMessageRequest,
        handler: Box<dyn Fn(&[u8]) -> DinkResult<()> + Send + Sync>,
    ) -> DinkResult<Box<dyn dink_sdk::Subscription>> {
        let req_data = serde_json::to_vec(req).map_err(dink_sdk::DinkError::from)?;
        self.caller
            .subscribe(
                &self.edge_id,
                "ZeroClawService",
                "StreamMessage",
                &req_data,
                handler,
            )
            .await
    }

    pub async fn get_status(&self, req: &GetStatusRequest) -> DinkResult<GetStatusResponse> {
        let req_data = serde_json::to_vec(req).map_err(dink_sdk::DinkError::from)?;
        let resp_data = self
            .caller
            .call(&self.edge_id, "ZeroClawService", "GetStatus", &req_data)
            .await?;
        let resp: GetStatusResponse =
            serde_json::from_slice(&resp_data).map_err(dink_sdk::DinkError::from)?;
        Ok(resp)
    }

    pub async fn recall_memory(
        &self,
        req: &RecallMemoryRequest,
    ) -> DinkResult<RecallMemoryResponse> {
        let req_data = serde_json::to_vec(req).map_err(dink_sdk::DinkError::from)?;
        let resp_data = self
            .caller
            .call(&self.edge_id, "ZeroClawService", "RecallMemory", &req_data)
            .await?;
        let resp: RecallMemoryResponse =
            serde_json::from_slice(&resp_data).map_err(dink_sdk::DinkError::from)?;
        Ok(resp)
    }

    pub async fn update_config(
        &self,
        req: &UpdateConfigRequest,
    ) -> DinkResult<UpdateConfigResponse> {
        let req_data = serde_json::to_vec(req).map_err(dink_sdk::DinkError::from)?;
        let resp_data = self
            .caller
            .call(&self.edge_id, "ZeroClawService", "UpdateConfig", &req_data)
            .await?;
        let resp: UpdateConfigResponse =
            serde_json::from_slice(&resp_data).map_err(dink_sdk::DinkError::from)?;
        Ok(resp)
    }

    pub async fn shutdown(&self, req: &ShutdownRequest) -> DinkResult<ShutdownResponse> {
        let req_data = serde_json::to_vec(req).map_err(dink_sdk::DinkError::from)?;
        let resp_data = self
            .caller
            .call(&self.edge_id, "ZeroClawService", "Shutdown", &req_data)
            .await?;
        let resp: ShutdownResponse =
            serde_json::from_slice(&resp_data).map_err(dink_sdk::DinkError::from)?;
        Ok(resp)
    }
}

/// Service definition constant for ZeroClawService.
pub const ZERO_CLAW_SERVICE_DEFINITION: ServiceDefinition = ServiceDefinition {
    name: "ZeroClawService",
    version: "1.0.0",
    methods: &[
        "SendMessage",
        "StreamMessage",
        "GetStatus",
        "RecallMemory",
        "UpdateConfig",
        "Shutdown",
    ],
};

/// Handler that dispatches incoming requests to a `ZeroClawServiceServer` implementation.
pub struct ZeroClawServiceHandler<S: ZeroClawServiceServer> {
    imp: S,
}

impl<S: ZeroClawServiceServer> ZeroClawServiceHandler<S> {
    pub fn new(imp: S) -> Self {
        Self { imp }
    }
}

#[async_trait]
impl<S: ZeroClawServiceServer + 'static> ServiceHandler for ZeroClawServiceHandler<S> {
    fn definition(&self) -> ServiceDefinition {
        ZERO_CLAW_SERVICE_DEFINITION
    }

    async fn handle_request(&self, method: &str, req_data: &[u8]) -> DinkResult<Vec<u8>> {
        match method {
            "SendMessage" => {
                let req: SendMessageRequest = if req_data.is_empty() {
                    SendMessageRequest::default()
                } else {
                    serde_json::from_slice(req_data)?
                };
                let resp = self.imp.send_message(req).await?;
                Ok(serde_json::to_vec(&resp)?)
            }
            "GetStatus" => {
                let req: GetStatusRequest = if req_data.is_empty() {
                    GetStatusRequest::default()
                } else {
                    serde_json::from_slice(req_data)?
                };
                let resp = self.imp.get_status(req).await?;
                Ok(serde_json::to_vec(&resp)?)
            }
            "RecallMemory" => {
                let req: RecallMemoryRequest = if req_data.is_empty() {
                    RecallMemoryRequest::default()
                } else {
                    serde_json::from_slice(req_data)?
                };
                let resp = self.imp.recall_memory(req).await?;
                Ok(serde_json::to_vec(&resp)?)
            }
            "UpdateConfig" => {
                let req: UpdateConfigRequest = if req_data.is_empty() {
                    UpdateConfigRequest::default()
                } else {
                    serde_json::from_slice(req_data)?
                };
                let resp = self.imp.update_config(req).await?;
                Ok(serde_json::to_vec(&resp)?)
            }
            "Shutdown" => {
                let req: ShutdownRequest = if req_data.is_empty() {
                    ShutdownRequest::default()
                } else {
                    serde_json::from_slice(req_data)?
                };
                let resp = self.imp.shutdown(req).await?;
                Ok(serde_json::to_vec(&resp)?)
            }
            _ => Err(dink_sdk::DinkError::UnknownMethod(method.to_string())),
        }
    }

    async fn handle_stream(
        &self,
        method: &str,
        req_data: &[u8],
        emit: Box<dyn Fn(Vec<u8>) -> DinkResult<()> + Send + Sync>,
    ) -> DinkResult<()> {
        match method {
            "StreamMessage" => {
                let req: SendMessageRequest = if req_data.is_empty() {
                    SendMessageRequest::default()
                } else {
                    serde_json::from_slice(req_data)?
                };
                self.imp.stream_message(req, emit).await
            }
            _ => Err(dink_sdk::DinkError::UnknownMethod(method.to_string())),
        }
    }

    fn webhook_methods(&self) -> Vec<dink_sdk::WebhookMethodMeta> {
        vec![
            dink_sdk::WebhookMethodMeta {
                method: "SendMessage".to_string(),
                secret_mode: "plain".to_string(),
                description: "".to_string(),
            },
            dink_sdk::WebhookMethodMeta {
                method: "StreamMessage".to_string(),
                secret_mode: "plain".to_string(),
                description: "".to_string(),
            },
            dink_sdk::WebhookMethodMeta {
                method: "GetStatus".to_string(),
                secret_mode: "plain".to_string(),
                description: "".to_string(),
            },
        ]
    }
}
